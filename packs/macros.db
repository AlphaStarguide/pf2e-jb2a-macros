{"name":"Heal","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"systems/pf2e/icons/spells/heal.webp","scope":"global","command":"//vardef\nlet caster = canvas.tokens.controlled[0]\nlet spellTarget = Array.from(game.user.targets)[0]\n\nlet d = new Dialog({\n    title: \"Heal\",\n    content: \"<p>How many actions are you using to cast Heal?</p>\",\n    buttons: {\n    one: {\n    icon: '<span class=\"pf2-icon\">1</span>',\n    label: \"One Action\",\n    callback: () => {\n        oneActionHeal()\n        }\n    },\n    two: {\n    icon: '<span class=\"pf2-icon\">2</span>',\n    label: \"Two Actions\",\n    callback: () => {\n        twoActionHeal()\n        }\n    },\n    three:{\n    icon: `<span class=\"pf2-icon\">3</span>`,\n    label: \"Three Actions\",\n    callback: () => {\n        threeActionHeal()\n        }\n    }\n    },\n    default: \"Two Actions\"\n})\n\nmain()\n\nfunction main(){\n    if(caster != undefined){\n        d.render(true);\n    }else{\n        ui.notifications.error(`You must select the token of the caster!`)\n        return;\n    }    \n}\n\n//Defining unique behavior for each kind of effect\n\n\nfunction oneActionHeal(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) < 7.5){\n            console.log(\"Close enough to touch!\")\n            // checks whether the target is undead or not\n            oneActionHealAnimation()\n        }else{\n            console.log(`Too far to touch!`); \n            ui.notifications.error(`Your target is further than touch distance away! Try again.`);\n            return;\n        }    \n}\n\nfunction twoActionHeal(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) <= 30){\n        console.log(\"Within 30 feet!\")\n        // checks whether the target is undead or not\n        twoActionHealAnimation()\n    }else{\n        console.log(`Farther than 30 feet!`); \n        ui.notifications.error(`Your target is further than 30 feet away! Try again.`);\n        return;\n    }\n}\n\nfunction threeActionHeal(){\n    //divide up all tokens within range into an array for living and an array for undead\n    let tokensOnMap = Array.from(canvas.tokens.placeables)\n    let tokensInRange = tokensOnMap.filter(distance => canvas.grid.measureDistance(distance,caster)<=30)\n    let tokenTraitsInRange = tokensInRange.map(x => x.actor.traits)\n    let undeadTokensInRange = []\n    let livingTokensInRange = []\n    for(let i=0;i<tokensInRange.length;i++){\n        if(Array.from(tokenTraitsInRange[i]).includes(`undead`)||Array.from(tokenTraitsInRange[i]).includes(`dhampir`)){\n            undeadTokensInRange.push(tokensInRange[i])\n        }else if(!Array.from(tokenTraitsInRange[i]).includes(`undead`)&&!Array.from(tokenTraitsInRange[i]).includes(`construct`)&&!Array.from(tokenTraitsInRange[i]).includes(`dhampir`)){\n            livingTokensInRange.push(tokensInRange[i])\n        }\n    }\n    console.log(undeadTokensInRange)\n    console.log(livingTokensInRange)\n    new Sequence()\n        .effect()\n            .atLocation(caster)\n            .randomRotation()\n            .size(14, {gridUnits: true})\n            .file(\"jb2a.healing_generic.burst.greenorange\")\n            .waitUntilFinished(-1500)\n        .play()\n    for(let i=0;i<undeadTokensInRange.length;i++){\n        new Sequence(\"Damage Undead\")\n            .effect()\n                .atLocation(undeadTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.divine_smite.target.greenyellow\")\n            .play()\n    }\n    for(let i=0;i<livingTokensInRange.length;i++){\n        new Sequence(\"Heal living\")\n            .effect()\n                .atLocation(livingTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.healing_generic.200px.green\")\n            .play()\n    }\n}\n\n//Defining animations for each kind of effect\n    function oneActionHealAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n        //trigger energy strand from caster to target, then trigger healing burst on target\n        new Sequence(\"Damage undead\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"Healjb2a.divine_smite.target.greenyellow\")\n            .play()\n        }else{\n        //trigger energy strand from caster to target, then trigger damaging burst on target\n        new Sequence(\"Heal living\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.healing_generic.200px.green\")\n            .effect()\n                .atLocation(spellTarget)\n                .scaleToObject()\n                .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                .delay(500)\n            .play()\n        }\n    }\n    function twoActionHealAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n            //trigger energy strand from caster to target, then trigger healing burst on target\n            new Sequence(\"Damage undead\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_purple\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"Healjb2a.divine_smite.target.greenyellow\")\n                .play()\n        }else{\n            //trigger energy strand from caster to target, then trigger damaging burst on target\n            new Sequence(\"Heal living\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_green\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"jb2a.healing_generic.200px.green\")\n                .play()\n        }\n    }\n    function threeActionHealAnimation(){\n        \n    }","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.1wpIPbvbCvQaueft"}},"_id":"CtkjmTtEYfMPbtm4"}
{"name":"Dancing Lights","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"icons/magic/light/explosion-star-glow-yellow.webp","scope":"global","command":"/* get the pixels equivalent to 5 feet */\nconst gridSquare = canvas.scene.data.size/(canvas.scene.data.gridDistance/5);\n\n/* we will be doing this a lot */\nconst twentyFeet = gridSquare * 4;\n\n/* assume click on our desired \"center\" */\nconst startingoffset = {x: -2*gridSquare, y: -2*gridSquare};\n\n/* backwards since thats how pop do */\nconst placementOffsets = [{x:-twentyFeet}, {y:twentyFeet}, {x:twentyFeet},{x: -2*gridSquare, y: -2*gridSquare}];\n\n/* pop the offsets off one at a time and mody 'location' by that much.\n * Remember, this is a culmulative iteration\n */\nconst offset = (location) => {\n    if (!!placementOffsets.length) {\n        const offset = placementOffsets.pop();\n        console.log('location, offset',location, offset)\n        location.x += offset.x ?? 0;\n        location.y += offset.y ?? 0;\n    }\n}\n\n/* we need to offset the initial placement with pre\n * and subsequent duplicates with post\n */\nconst callbacks = {\n    pre: offset,\n    post: offset\n}\n\nconst config = {\n    interval: -1\n}\n\n/* Helper function to find and remove an array element by value */\nfunction findDelete(source, searchElement){\n    const index = source.indexOf(searchElement);\n    if (index > -1) {\n        source.splice(index, 1);\n        return true;\n    }\n    return false;\n}\n\n/* Spawn in our lights with dimLight already set*/\nconst lightsIds = await warpgate.spawn(\"Dancing Light\", {}, callbacks, {duplicates:4, crosshairs:config});\n\n/* We are already dismissing the current actor, hence\n * this trigger firing. We need to now dismiss\n * the remianing 3 lights.\n */\nconst deleteOthers = async (eventData) => {\n    \n    /* whoever we are, we are already being deleted */\n    findDelete(lightsIds, eventData.actorData.token._id);\n    \n    for( const id of lightsIds ){\n        // @todo dismiss really should take an array of ids\n        new Sequence()\n            .effect()\n                .atLocation(id)\n                .file(\"jb2a.template_circle.out_pulse.02.burst\")\n                .scaleToObject(2)\n                .fadeOut(500)\n            .play()\n        await warpgate.dismiss(id, eventData.sceneId);\n    }\n}\n\n/* we only want our event to trigger when it involves\n * one of our just-spawned lightsIds\n */\nconst condition = (eventData) => {\n    return lightsIds.includes(eventData.actorData.token._id)\n}\n\n/* Set up a trigger for when one of our\n * lights is dismissed, all of them\n * get dismissed\n */\nwarpgate.event.trigger(warpgate.EVENT.DISMISS, deleteOthers, condition)","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.1wpIPbvbCvQaueft"}},"_id":"KHYzBiPwMIY6WfYa"}
{"name":"Harm","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"systems/pf2e/icons/spells/harm.webp","scope":"global","command":"//vardef\nlet caster = canvas.tokens.controlled[0]\nlet spellTarget = Array.from(game.user.targets)[0]\nlet doNotTargetCaster = false\n\nlet d = new Dialog({\n    title: \"Harm\",\n    content: \"<p>How many actions are you using to cast Harm?</p>\",\n    buttons: {\n    one: {\n    icon: '<span class=\"pf2-icon\">1</span>',\n    label: \"One Action\",\n    callback: () => {\n        oneActionHarm()\n        }\n    },\n    two: {\n    icon: '<span class=\"pf2-icon\">2</span>',\n    label: \"Two Actions\",\n    callback: () => {\n        twoActionHarm()\n        }\n    },\n    three:{\n    icon: `<span class=\"pf2-icon\">3</span>`,\n    label: \"Three Actions\",\n    callback: () => {\n        d2.render(true);\n        }\n    }\n    },\n    default: \"Two Actions\"\n})\n\nconsole.log(caster)\nlet d2 = new Dialog({\n    title: \"Harm\",\n    content: `<p>Do you want to target yourself? ${true ? \"This action will heal you.\" : \"This action will hurt you.\"}</p>`,\n    buttons: {\n    one: {\n    label: \"Yes\",\n    callback: () => {\n        doNotTargetCaster = false\n        threeActionHarm()\n        }\n    },\n    two: {\n    label: \"No\",\n    callback: () => {\n        doNotTargetCaster = true\n        threeActionHarm()\n        }\n    }\n    },\n    default: \"No\"\n})\n\nmain()\n\nfunction main(){\n    if(caster != undefined){\n        d.render(true);\n    }else{\n        ui.notifications.error(`You must select the token of the caster!`)\n        return;\n    }    \n}\n\n//Defining unique behavior for each kind of effect\n\n\nfunction oneActionHarm(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) < 7.5){\n            console.log(\"Close enough to touch!\")\n            // checks whether the target is undead or not\n            oneActionHarmAnimation()\n        }else{\n            console.log(`Too far to touch!`); \n            ui.notifications.error(`Your target is further than touch distance away! Try again.`);\n            return;\n        }    \n}\n\nfunction twoActionHarm(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) <= 30){\n        console.log(\"Within 30 feet!\")\n        // checks whether the target is undead or not\n        twoActionHarmAnimation()\n    }else{\n        console.log(`Farther than 30 feet!`); \n        ui.notifications.error(`Your target is further than 30 feet away! Try again.`);\n        return;\n    }\n}\n\nfunction threeActionHarm(){\n    //divide up all tokens within range into an array for living and an array for undead\n    let tokensOnMap = Array.from(canvas.tokens.placeables)\n    let tokensInRange = tokensOnMap.filter(distance => canvas.grid.measureDistance(distance,caster)<=30)\n    let tokenTraitsInRange = tokensInRange.map(x => x.actor.traits)\n    let undeadTokensInRange = []\n    let livingTokensInRange = []\n    for(let i=0;i<tokensInRange.length;i++){\n        if(Array.from(tokenTraitsInRange[i]).includes(`undead`)){\n            undeadTokensInRange.push(tokensInRange[i])\n        }else if(!Array.from(tokenTraitsInRange[i]).includes(`undead`) && !Array.from(tokenTraitsInRange[i]).includes(`construct`)){\n            if (doNotTargetCaster) {\n                if (!(caster === tokensInRange[i])) livingTokensInRange.push(tokensInRange[i])\n            } else livingTokensInRange.push(tokensInRange[i])\n  \n        }\n    }\n    console.log(undeadTokensInRange)\n    console.log(livingTokensInRange)\n    new Sequence()\n        .effect()\n            .atLocation(caster)\n            .randomRotation()\n            .size(15, {gridUnits: true})\n            .file(\"jb2a.healing_generic.burst.purplepink\")\n            .waitUntilFinished(-1500)\n        .play()\n    for(let i=0;i<undeadTokensInRange.length;i++){\n        new Sequence(\"Heal Undead\")\n            .effect()\n                .atLocation(undeadTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.cure_wounds.400px.purple\")\n            .play()\n    }\n    for(let i=0;i<livingTokensInRange.length;i++){\n        new Sequence(\"Harm living\")\n            .effect()\n                .atLocation(livingTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.divine_smite.caster.dark_purple\")\n            .effect()\n                .atLocation(livingTokensInRange[i])\n                .scaleToObject()\n                .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                .delay(500)\n            .play()\n    }\n}\n\n//Defining animations for each kind of effect\n    function oneActionHarmAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n        //trigger energy strand from caster to target, then trigger healing burst on target\n        new Sequence(\"Heal undead\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.cure_wounds.400px.purple\")\n            .play()\n        }else{\n        //trigger energy strand from caster to target, then trigger damaging burst on target\n        new Sequence(\"Harm living\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.divine_smite.caster.dark_purple\")\n            .effect()\n                .atLocation(spellTarget)\n                .scaleToObject()\n                .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                .delay(500)\n            .play()\n        }\n    }\n    function twoActionHarmAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n            //trigger energy strand from caster to target, then trigger healing burst on target\n            new Sequence(\"Heal undead\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_purple\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"jb2a.cure_wounds.400px.purple\")\n                .play()\n        }else{\n            //trigger energy strand from caster to target, then trigger damaging burst on target\n            new Sequence(\"Harm living\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_purple\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"jb2a.divine_smite.caster.dark_purple\")\n                .effect()\n                    .atLocation(spellTarget)\n                    .scaleToObject()\n                    .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                    .delay(500)\n                .play()\n        }\n    }\n    function threeActionHarmAnimation(){\n        \n    }","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.OHxEXANJvgNk9uTU"}},"_id":"kz6IN257FJ58SgmE"}
{"name":"Grim Tendrils","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"icons/magic/unholy/energy-smoke-pink.webp","scope":"global","command":"const template = args[1].templateData;\nconst [templateX, templateY] = [template.data.x, template.data.y];\nnew Sequence()\n    .effect()\n        .file('jb2a.energy_strands.range.multiple.dark_purple.01')\n        .fadeIn(500)\n        .fadeOut(500)\n        .atLocation(template)\n        .rotateTowards(template)\n        .stretchTo(template)\n        .scale({ x: 1.4 })\n        .spriteOffset({ x: -150 })\n    .play()","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.1wpIPbvbCvQaueft"}},"_id":"pC8bqYNdqGeeUoWO"}
{"name":"Magic Missile","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"icons/magic/lightning/projectiles-tendril-salvo-pink.webp","scope":"global","command":"/*\nThis version of the Magic Missile Macro Automatically expends slots(prepared), spell uses(spontaneous), charges(wands), and consumes scrolls.\nWhen Wand of Manifold Missile is used, it places an effect on the character that allows it to tell if you are using the lingering effect of those wands. This adds the option to terminate the effect from within the dialog box through a checkbox (nothing else happens), or select the effect and have it shoot Magic Missiles as per the wand's description.\nDo not make spellcasting entries for your wands or scrolls. If you would like to use that method, please use the original macro.\nFor staves please use a spellcasting entry due to the nature of how staves work.\nThe macro will not prompt for trick magic item due to DCs being variable. May change this in the future.\n\nThis macro was written by Symon S and was modified slightly by Syven to include jb2a's animations.\n*/\n\nconst mani = [\"wand-of-manifold-missiles-1st-level-spell\",\"wand-of-manifold-missiles-3rd-level-spell\",\"wand-of-manifold-missiles-5th-level-spell\",\"wand-of-manifold-missiles-7th-level-spell\"]\nif (!token.actor.itemTypes.spell.some(s => s.slug === 'magic-missile') && !token.actor.itemTypes.consumable.some(s => s.data.data.spell?.data?.data?.slug === 'magic-missile') && !token.actor.itemTypes.equipment.some(s => mani.includes(s.slug))) { return ui.notifications.error('You do not have Magic Missile') }if (game.user.targets.ids === undefined || game.user.targets.ids.length === 0) { return ui.notifications.error('At least 1 target is required'); }\n\nconst mmE = token.actor.itemTypes.spellcastingEntry.filter(m => m.spells.some(x => x.slug === 'magic-missile') === true);\n\nconst mmIds = [];\ntoken.actor.itemTypes.spell.forEach(id => {\n\tif(id.slug === 'magic-missile') { mmIds.push(id.id); }\n});\n\nconst mm = [];\nconst formula =  `{1d4 + 1}[force]`;\n\nmmE.forEach(e => {\n          const spellData = e.getSpellData();\n\t  spellData.levels.forEach(sp => {\n            if(sp.uses !== undefined && !sp.isCantrip && sp.uses.value < 1) { return; }\n\t    sp.active.forEach((spa,index) => {\n\t      if(spa === null) { return; }\n              if(spa.spell.slug !== \"magic-missile\") { return; }\n              if(spa.expended) { return; }\n              if(spellData.isFocusPool && !spa.spell.isCantrip && token.actor.data.data.resources.focus.value === 0){ return; }\n              let level = `lv${sp.level}`\n              const name = spa.spell.name;\n\t      const sname = `${name} ${level} (${e.name})`;\n              mm.push({name: sname, entryId: spellData.id, level: sp.level, spId: spa.spell.id, slug: spa.spell.slug, DC: e.data.data.statisticData.dc.value, spell: spa.spell, index: index});\n\t    });\n\t  });\n});\t\n\ntoken.actor.itemTypes.consumable.forEach(s => {\n\tif (!s.data.data.traits.value.includes(\"wand\") && !s.data.data.traits.value.includes(\"scroll\")) { return; }\n\tif (s.data.data.spell.data.data.slug === 'magic-missile') { \n\t\tif (s.data.data.traits.value.includes(\"wand\") && s.data.data.charges.value > 0) {\n\t\t\tmm.push({name: `${s.name}`, level: parseInt(s.slug.substr(11,1)), prepared: false, entryId: s.id , wand: true, scroll: false, spont: false,  }) \n\t\t}\n\t\tif (s.data.data.traits.value.includes(\"scroll\")) {\n\t\t\tmm.push({name: `${s.name}`, level: s.data.data.spell.heightenedLevel, prepared: false, entryId: s.id, wand: false, scroll: true, spont: false })\n\t\t}\n\t}\n});\ntoken.actor.itemTypes.equipment.forEach(s => {\n\tif (mani.includes(s.slug)) { \n\t\tmm.push({name: `${s.name}`, level: parseInt(s.slug.substr(26,1)), prepared: false, entryId: s.slug, wand: true, scroll: false, spont: false}); \n\t}\n});\n\nif (token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")) {\n\tconst effect = token.actor.itemTypes.effect.find(e => e.slug === \"maniEF\");\n\tmm.push({name: `${effect.name}`, level: effect.data.data.level.value, prepared: false, entryId: null, wand: false, scroll: false, spont: false });\n}\n\nif (mm.length === 0) { return ui.notifications.warn(\"You currently have no available means of casting Magic Missile\");}\n\nconst mmdd = [{label: 'Which spell?', type: 'select', options: mm.map(n => n.name)},\n\t      {label: 'Number of Actions?', type: 'select', options: [3,2,1]}\n\t     ];\n\nif (token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")) { mmdd.push({label: `Remove Effect Instead?`, type: \"checkbox\"})}\n\nconst mmdiag = await quickDialog({data : mmdd, title : `Magic Missile`});\n\nif (mmdiag[2] === true) { \n\tconst effect = token.actor.itemTypes.effect.find(e => e.slug === \"maniEF\")\n\tawait effect.delete();\n\treturn;\n}\n\nconst mmch = mm.find(n => n.name === mmdiag[0]);\n\nif(mmch.entryId === null) { mmdiag[1] = 1 }\n\nconst multi = parseInt(mmdiag[1]) * Math.floor((1 + mmch.level)/2);\n\nconst targetIds = game.user.targets.ids;\nconst targets = canvas.tokens.placeables.filter(t => targetIds.includes(t.id));\n\nconst tdata = [];\ntargets.forEach(t => {\n\tif(t.actor.hasPlayerOwner) { ui.notifications.info(`${t.name} is most likely an ally`);}\n\ttdata.push({label: t.name, type: 'number', options: [1]});\n});\n\nif (targetIds.length === 1) { tdata[0].options = [multi]; }\n\nconst tdiag = await quickDialog({data : tdata, title : `Distribute ${multi} Missiles`});\n\nlet tot = 0;\nlet i;\nconst fmm = [];\ntdiag.forEach(m => {\n\ttot = tot + m\n\tif( i !== undefined) { i++ }\n\tif( i === undefined) { i = 0}\n\tfmm.push({name: targets[i].name, num: m})\n});\n\nif (tot > multi) { return ui.notifications.warn(`You have entered ${tot - multi} too many missiles. Please try again`)}\nif (tot < multi) { return ui.notifications.warn(`You have entered ${ multi - tot} too few missiles. Please try again`)}\n\nconsole.log(targets)\n\nlet targetNum = 0\nfmm.forEach(a => {\n        if(a.num === 0 || a.num === undefined) { return; }\n\tlet dam = token.actor.itemTypes.feat.some(ds => ds.slug === 'dangerous-sorcery') ? formula.repeat(a.num).replace(/]{/g,'] + {') + ` + {${mmch.level}}[status,force]` : formula.repeat(a.num).replace(/]{/g,'] + {');\n\tvar droll = new Roll(dam);\n        droll.toMessage({ flavor: `<strong>${a.num} Magic Missile(s) targeting ${a.name}</strong><br><a class=\"entity-link content-link\" data-pack=\"pf2e.spells-srd\" data-id=\"gKKqvLohtrSJj3BM\"><strong>Magic Missile</strong></a>`, speaker: ChatMessage.getSpeaker() });\n \tnew Sequence()\n        .effect()\n            .file(`jb2a.magic_missile.green`)\n            .atLocation(canvas.tokens.controlled[0])\n            .stretchTo(targets[targetNum])\n            .repeats(a.num,100,300)\n            .delay(300,600)\n        .play()\n    targetNum++\n    });\n\nconst s_entry = mmE.find(e => e.id === mmch.entryId);\n\n/* Expend slots */\nif (!mmch.wand && !mmch.scroll) { \n  await s_entry.cast(mmch.spell,{slot: mmch.index,level: mmch.level,message: false});\n}\n\n\n/* Wand */\nif (mmch.wand) {\n\tif (mani.includes(mmch.entryId)) {\n\t\tif (token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")) {\n\t\t\tconst effect = token.actor.itemTypes.effect.find(e => e.slug === \"maniEF\")\n\t\t\tawait effect.delete();\n\t\t}\n\t\tif (!token.actor.itemTypes.effect.some(e => e.slug === \"maniEF\")){\n\t\t\tconst maniEF = {\n  \t\t\t\t\"name\": `${mmch.name} Effect`,\n  \t\t\t\t\"type\": \"effect\",\n  \t\t\t\t\"img\": \"systems/pf2e/icons/equipment/wands/specialty-wands/wand-of-manifold-missiles.webp\",\n  \t\t\t\t\"data\": {\n    \t\t\t\t\t\"description\": {\n      \t\t\t\t\t\t\"value\": `<p><strong>Requirements</strong> You used Wand of Manifold Missiles to cast Magic Missile.</p>\\n<hr />\\n<p>After you cast the spell, an additional missile or missiles are released from the wand at the start of each of your turns, as though you cast the 1-action version of magic missile. Choose targets each time. This lasts for 1 minute, until you are no longer wielding the wand, or until you try to activate the wand again.</p>`\n    \t\t\t\t\t},\n    \t\t\t\t\t\"source\": {\n\t\t\t\t\t\t\"value\": \"\"\n    \t\t\t\t\t},\n    \t\t\t\t\t\"traits\": {\n\t\t\t\t\t\t\"value\": [],\n      \t\t\t\t\t\t\"rarity\": {\n        \t\t\t\t\t\"value\": \"common\"\n\t\t\t\t\t\t},\n \t\t\t\t\t\t\"custom\": \"\"\n    \t\t\t\t\t},\n\t\t\t\t\t\"rules\": [],\n    \t\t\t\t\t\"slug\": \"maniEF\",\n    \t\t\t\t\t\"schema\": {\n      \t\t\t\t\t\t\"version\": 0.697,\n\t\t\t\t\t\t\"lastMigration\": null\n    \t\t\t\t\t},\n    \t\t\t\t\t\"level\": {\n\t\t\t\t\t\t\"value\": mmch.level\n    \t\t\t\t\t},\n    \t\t\t\t\t\"duration\": {\n\t\t\t\t\t\t\"value\": -1,\n      \t\t\t\t\t\t\"unit\": \"unlimited\",\n      \t\t\t\t\t\t\"sustained\": false,\n      \t\t\t\t\t\t\"expiry\": \"turn-start\"\n    \t\t\t\t\t},\n    \t\t\t\t\t\"start\": {\n\t\t\t\t\t\t\"value\": 0,\n      \t\t\t\t\t\t\"initiative\": null\n    \t\t\t\t\t},\n    \t\t\t\t\t\"target\": null,\n    \t\t\t\t\t\"tokenIcon\": {\n\t\t\t\t\t\t\"show\": true\n\t\t\t\t\t}\n  \t\t\t\t},\n  \t\t\t\t\"effects\": [],\n\t\t\t\t\"sort\": 0\n\t\t\t};\n\t\t\tawait actor.createEmbeddedDocuments('Item', [maniEF]);\n\t\t}\n\t}\n\telse {\n\t\tconst w = token.actor.itemTypes.consumable.find(id => id.id === mmch.entryId);\n\t\tconst wData = duplicate(w.data);\n\t\twData.data.charges.value --;\n\t\tw.update(wData);\n\t}\n}\n\n/* Scroll */\nif(mmch.scroll){\n\tconst s = token.actor.itemTypes.consumable.find(id => id.id === mmch.entryId);\n\tif (s.data.data.quantity > 1) {\n\t\tconst sData = duplicate(s.data);\n\t\tsData.data.quantity --;\n\t\ts.update(sData);\n\t}\n\telse { await s.delete(); }\n}\n\n\n/* Dialog box */\nasync function quickDialog({data, title = `Quick Dialog`} = {}) {\n\tdata = data instanceof Array ? data : [data];\n\n\treturn await new Promise(async (resolve) => {\n\t        let content = `\n        \t<table style=\"width:100%\">\n          \t${data.map(({type, label, options}, i)=> {\n          \t\tif(type.toLowerCase() === `select`)\n          \t{\n          \t\treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><select style=\"font-size:12px\" id=\"${i}qd\">${options.map((e,i)=> `<option value=\"${e}\">${e}</option>`).join(``)}</td></tr>`;\n          \t}else if(type.toLowerCase() === `checkbox`){\n            \t\treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" ${options || ``}/></td></tr>`;\n          \t}else{\n            \t\treturn `<tr><th style=\"width:50%\"><label>${label}</label></th><td style=\"width:50%\"><input type=\"${type}\" id=\"${i}qd\" value=\"${options instanceof Array ? options[0] : options}\"/></td></tr>`;\n          \t}\n          \t}).join(``)}\n        \t</table>`;\n\n        await new Dialog({\n         title, content,\n         buttons : {\n           Ok : { label : `Ok`, callback : (html) => {\n             resolve(Array(data.length).fill().map((e,i)=>{\n               let {type} = data[i];\n               if(type.toLowerCase() === `select`)\n               {\n                 return html.find(`select#${i}qd`).val();\n               }else{\n                 switch(type.toLowerCase())\n                 {\n                   case `text` :\n                   case `password` :\n                   case `radio` :\n                   return html.find(`input#${i}qd`)[0].value;\n                  case `checkbox` :\n                  return html.find(`input#${i}qd`)[0].checked;\n                  case `number` :\n                  return html.find(`input#${i}qd`)[0].valueAsNumber;\n                }\n              }\n            }));\n          }}\n        },\n        default : 'Ok'\n        })._render(true);\n        document.getElementById(\"0qd\").focus();\n      });\n    }","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.OHxEXANJvgNk9uTU"}},"_id":"pXVewDMcOapNzVcO"}
