{"_id":"1dUKN6KL7g3cdDdz","name":"Bouncing Lightning","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"systems/pf2e/icons/spells/electric-arc.webp","scope":"global","command":"let token = args[1].sourceToken\nlet targetTokens = Array.from(game.user.targets)\nlet sequence = new Sequence() // this is the naimation part, handled by the Sequencer module\n    .effect()\n        .file(\"jb2a.chain_lightning.primary.blue\")\n        .atLocation(token) // Going from origin\n        .stretchTo(targetTokens[0]) // To the current loop's target                                            \n        .waitUntilFinished(-1100)// The next sequence will start 1.1 seconds before the end of the primary Lightning\n    .sound()\n        .file(\"modules/soundfxlibrary/Combat/Single/Spell%20Impact%20Lightning/spell-impact-lightning-3.mp3\")\n        .fadeInAudio(500)\n        .fadeOutAudio(500)\n    .effect()\n        .file(\"jb2a.static_electricity.02.blue\")\n        .atLocation(targetTokens[0])\n        .scaleToObject()\n        .repeats(2)\n        .wait(100)\nfor (let i = 1; i < targetTokens.length; i++) {\n    sequence\n        .effect()\n            .file(\"jb2a.chain_lightning.secondary.blue\")\n            .repeats(2)\n            .atLocation(targetTokens[i - 1]) // Going from origin\n            .stretchTo(targetTokens[i]) // To the current loop's target\n            .wait(200)\n        .sound()\n            .file(\"modules/soundfxlibrary/Combat/Single/Spell%20Impact%20Lightning/spell-impact-lightning-4.mp3\")\n            .fadeInAudio(500)\n            .fadeOutAudio(500)\n        .effect()\n            .file(\"jb2a.static_electricity.02.blue\")\n            .atLocation(targetTokens[i])\n            .scaleToObject()\n            .repeats(2)\n            .wait(200)\n}\nsequence.play()","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"core":{"sourceId":"Macro.a6jod3yUvFLPBT8W"},"advanced-macros":{"runAsGM":false}}}
{"_id":"CtkjmTtEYfMPbtm4","name":"Heal","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"systems/pf2e/icons/spells/heal.webp","scope":"global","command":"let diceNumber = args[0]._roll.terms[0].number\nlet caster = args[1].sourceToken\nlet spellTarget = Array.from(game.user.targets)[0]\nlet doNotTargetCaster = false\n\nlet d = new Dialog({\n    title: \"Heal\",\n    content: \"<p>How many actions are you using to cast Heal?</p>\",\n    buttons: {\n    one: {\n    icon: '<span class=\"pf2-icon\">1</span>',\n    label: \"One Action\",\n    callback: () => {\n        spellTarget = Array.from(game.user.targets)[0]\n        oneActionHeal()\n        }\n    },\n    two: {\n    icon: '<span class=\"pf2-icon\">2</span>',\n    label: \"Two Actions\",\n    callback: () => {\n        d2.render(true)\n        }\n    },\n    three:{\n    icon: `<span class=\"pf2-icon\">3</span>`,\n    label: \"Three Actions\",\n    callback: () => {\n        d3.render(true)\n        }\n    }\n    },\n    default: \"Two Actions\"\n})\n\nlet d2 = new Dialog({\n    title: \"Heal\",\n    content: `<p>Post Increased Healing?</p>`,\n    buttons: {\n    one: {\n    label: \"Yes\",\n    callback: () => {\n        let r = new Roll(`8 * @diceNumber`, {diceNumber})\n        r.toMessage()\n        spellTarget = Array.from(game.user.targets)[0]\n        twoActionHeal()\n        }\n    },\n    two: {\n    label: \"No\",\n    callback: () => {\n        spellTarget = Array.from(game.user.targets)[0]\n        twoActionHeal()\n        }\n    }\n    },\n    default: \"No\"\n})\n\nlet d3 = new Dialog({\n    title: \"Heal\",\n    content: `<p>Do you want to target yourself?</p>`,\n    buttons: {\n    one: {\n    label: \"Yes\",\n    callback: () => {\n        doNotTargetCaster = false\n        threeActionHeal()\n        }\n    },\n    two: {\n    label: \"No\",\n    callback: () => {\n        doNotTargetCaster = true\n        threeActionHeal()\n        }\n    }\n    },\n    default: \"No\"\n})\n\nmain()\n\nfunction main(){\n    if(caster != undefined){\n        d.render(true);\n    }else{\n        ui.notifications.error(`You must select the token of the caster!`)\n        return;\n    }    \n}\n\n//Defining unique behavior for each kind of effect\n\n\nfunction oneActionHeal(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) < 7.5){\n            console.log(\"Close enough to touch!\")\n            // checks whether the target is undead or not\n            oneActionHealAnimation()\n        }else{\n            console.log(`Too far to touch!`); \n            ui.notifications.error(`Your target is further than touch distance away! Try again.`);\n            return;\n        }    \n}\n\nfunction twoActionHeal(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) <= 30){\n        console.log(\"Within 30 feet!\")\n        // checks whether the target is undead or not\n        twoActionHealAnimation()\n    }else{\n        console.log(`Farther than 30 feet!`); \n        ui.notifications.error(`Your target is further than 30 feet away! Try again.`);\n        return;\n    }\n}\n\nfunction threeActionHeal(){\n    //divide up all tokens within range into an array for living and an array for undead\n    let tokensOnMap = Array.from(canvas.tokens.placeables)\n    let tokensInRange = tokensOnMap.filter(distance => canvas.grid.measureDistance(distance,caster)<=30)\n    let tokenTraitsInRange = tokensInRange.map(x => x.actor.traits)\n    let undeadTokensInRange = []\n    let livingTokensInRange = []\n    for(let i=0;i<tokensInRange.length;i++){\n        if(Array.from(tokenTraitsInRange[i]).includes(`undead`)||Array.from(tokenTraitsInRange[i]).includes(`dhampir`)){\n            undeadTokensInRange.push(tokensInRange[i])\n        }else if(!Array.from(tokenTraitsInRange[i]).includes(`undead`)&&!Array.from(tokenTraitsInRange[i]).includes(`construct`)&&!Array.from(tokenTraitsInRange[i]).includes(`dhampir`)){\n            if (doNotTargetCaster) {\n                if (!(caster === tokensInRange[i])) livingTokensInRange.push(tokensInRange[i])\n            } else livingTokensInRange.push(tokensInRange[i])\n        }\n    }\n    console.log(undeadTokensInRange)\n    console.log(livingTokensInRange)\n    new Sequence()\n        .effect()\n            .atLocation(caster)\n            .randomRotation()\n            .size(14, {gridUnits: true})\n            .file(\"jb2a.healing_generic.burst.greenorange\")\n            .waitUntilFinished(-1500)\n        .play()\n    for(let i=0;i<undeadTokensInRange.length;i++){\n        new Sequence(\"Damage Undead\")\n            .effect()\n                .atLocation(undeadTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.divine_smite.target.greenyellow\")\n            .play()\n    }\n    for(let i=0;i<livingTokensInRange.length;i++){\n        new Sequence(\"Heal living\")\n            .effect()\n                .atLocation(livingTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.healing_generic.200px.green\")\n            .play()\n    }\n}\n\n//Defining animations for each kind of effect\n    function oneActionHealAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n        //trigger energy strand from caster to target, then trigger healing burst on target\n        new Sequence(\"Damage undead\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"Healjb2a.divine_smite.target.greenyellow\")\n            .play()\n        }else{\n        //trigger energy strand from caster to target, then trigger damaging burst on target\n        new Sequence(\"Heal living\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.healing_generic.200px.green\")\n            .effect()\n                .atLocation(spellTarget)\n                .scaleToObject()\n                .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                .delay(500)\n            .play()\n        }\n    }\n    function twoActionHealAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n            //trigger energy strand from caster to target, then trigger healing burst on target\n            new Sequence(\"Damage undead\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_purple\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"Healjb2a.divine_smite.target.greenyellow\")\n                .play()\n        }else{\n            //trigger energy strand from caster to target, then trigger damaging burst on target\n            new Sequence(\"Heal living\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_green\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"jb2a.healing_generic.200px.green\")\n                .play()\n        }\n    }\n    function threeActionHealAnimation(){\n        \n    }","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.1wpIPbvbCvQaueft"}}}
{"_id":"KHYzBiPwMIY6WfYa","name":"Dancing Lights","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"icons/magic/light/explosion-star-glow-yellow.webp","scope":"global","command":"/* get the pixels equivalent to 5 feet */\nconst gridSquare = canvas.scene.data.size/(canvas.scene.data.gridDistance/5);\n\n/* we will be doing this a lot */\nconst twentyFeet = gridSquare * 4;\n\n/* assume click on our desired \"center\" */\nconst startingoffset = {x: -2*gridSquare, y: -2*gridSquare};\n\n/* backwards since thats how pop do */\nconst placementOffsets = [{x:-twentyFeet}, {y:twentyFeet}, {x:twentyFeet},{x: -2*gridSquare, y: -2*gridSquare}];\n\n/* pop the offsets off one at a time and mody 'location' by that much.\n * Remember, this is a culmulative iteration\n */\nconst offset = (location) => {\n    new Sequence()\n        .effect()\n            .atLocation(location)\n            .file(\"jb2a.template_circle.out_pulse.02.burst\")\n            .scaleToObject(2)\n            .fadeOut(500)\n        .play()\n    if (!!placementOffsets.length) {\n        const offset = placementOffsets.pop();\n        console.log('location, offset',location, offset)\n        location.x += offset.x ?? 0;\n        location.y += offset.y ?? 0;\n    }\n}\n\n/* we need to offset the initial placement with pre\n * and subsequent duplicates with post\n */\nconst callbacks = {\n    pre: offset,\n    post: offset\n}\n\nconst config = {\n    interval: -1\n}\n\n/* Helper function to find and remove an array element by value */\nfunction findDelete(source, searchElement){\n    const index = source.indexOf(searchElement);\n    if (index > -1) {\n        source.splice(index, 1);\n        return true;\n    }\n    return false;\n}\n\n/* Spawn in our lights with dimLight already set*/\nconst lightsIds = await warpgate.spawn(\"Dancing Light\", {}, callbacks, {duplicates:4, crosshairs:config});\n\n/* We are already dismissing the current actor, hence\n * this trigger firing. We need to now dismiss\n * the remianing 3 lights.\n */\nconst deleteOthers = async (eventData) => {\n    \n    /* whoever we are, we are already being deleted */\n    findDelete(lightsIds, eventData.actorData.token._id);\n    \n    for( const id of lightsIds ){\n        // @todo dismiss really should take an array of ids\n        new Sequence()\n            .effect()\n                .atLocation(id)\n                .file(\"jb2a.template_circle.out_pulse.02.burst\")\n                .scaleToObject(2)\n                .fadeOut(500)\n            .play()\n        await warpgate.dismiss(id, eventData.sceneId);\n    }\n}\n\n/* we only want our event to trigger when it involves\n * one of our just-spawned lightsIds\n */\nconst condition = (eventData) => {\n    return lightsIds.includes(eventData.actorData.token._id)\n}\n\n/* Set up a trigger for when one of our\n * lights is dismissed, all of them\n * get dismissed\n */\nwarpgate.event.trigger(warpgate.EVENT.DISMISS, deleteOthers, condition)","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.1wpIPbvbCvQaueft"}}}
{"_id":"LxFkyULbmva8yGDm","name":"Bane_Animation","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"systems/pf2e/icons/spells/bane.webp","scope":"global","command":"let caster = args[1].sourceToken\n\nlet baneAnim = Sequencer.EffectManager.getEffects({ origin: \"BaneAnim\", source: caster })[0]\n\nlet thereIsIntro = Sequencer.EffectManager.getEffects({ origin: \"BaneAnim\", name: \"Bane Intro\" })[0] //locates the bane animation created by Bane_Animation\n\nfunction main() {\n    //checks to ensure a single token is selected\n    if (canvas.tokens.controlled.length == 0) {\n        ui.notifications.error(\"Select the token on which a bane effect is active.\")\n        return\n    } else if (canvas.tokens.controlled.length > 1) {\n        ui.notifications.error(\"Select only one token.\")\n        return\n    }\n}\nif (baneAnim) {\n    let endAnimation = await warpgate.menu({\n        inputs: [{ type: 'info', label: 'End, Keep, or Expand the Bane Animation?'},],\n        buttons: [{\n            label: 'End',\n            value: 1\n        }, {\n            label: 'Keep',\n            value: 2\n        }, {\n            label: 'Expand',\n            value: 3\n        }]\n    }, { title: \"Bane\" })\n    console.log(endAnimation)\n    if (endAnimation.buttons === 1) {\n        Sequencer.EffectManager.endEffects({ origin: \"BaneAnim\", source: caster })[0]\n    } else if (endAnimation.buttons === 3) {\n        let incrementValue = 3; //3 is the value for radius = 1 square\n\n        main()\n\n        //checks to make sure bane is active on the selected token\n        if (Sequencer.EffectManager.getEffects({ origin: \"BaneAnim\", source: caster })[0] === undefined) {\n            ui.notifications.error(`There are no instances of the bane effect active on this token.`)\n            return\n        }\n\n        //increments the radius of the effect by 1 square\n        baneAnim.update({\n            size: {\n                width: baneAnim.data.size.width + incrementValue,\n                height: baneAnim.data.size.height + incrementValue,\n                gridUnits: true\n            }\n        })\n    }\n\n} else if (!thereIsIntro) {\n    new Sequence(\"Bane\")\n        .effect()\n            .file(\"jb2a.bless.400px.intro.purple\")\n            .scaleIn(2, 1000, {ease: \"easeInBounce\"})\n            .atLocation(caster)\n            .waitUntilFinished(-500)\n            .name(\"Bane Intro\")\n            .origin(\"BaneAnim\")\n        .effect()\n            .file(\"jb2a.bless.400px.loop.purple\")\n            .atLocation(caster)\n            .fadeOut(500)\n            .persist()\n            .attachTo(caster)\n            .belowTokens(true)\n            .origin(\"BaneAnim\")\n            .name(\"Bane\")\n            .scaleOut(0, 500, {ease: \"easeOutCubic\"})\n            .size(4, { gridUnits: true })\n        .play()\n}","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"core":{"sourceId":"Macro.eJJhPoLdv7ul62dc"},"advanced-macros":{"runAsGM":false}}}
{"_id":"XtFJjALF0A4VvgRn","name":"Invisibility","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"icons/svg/blind.svg","scope":"global","command":"let token = args[1].sourceToken\nif (args[0] == \"on\") {\n    new Sequence()\n        .animation()\n            .on(token)\n            .fadeOut(1000)\n        .effect()\n            .file(\"jb2a.markers.circle_of_stars.yellowblue\")\n            .fadeIn(1000)\n            .name(\"Invisible\")\n            .atLocation(token)\n            .mask()\n            .fadeOut(1000)\n            .name(\"Invisible\")\n            .scaleToObject(2)\n            .attachTo(token, {bindAlpha: false, bindVisibility: false})\n            .persist()\n        .play()\n} else if (args[0] == \"off\") {\n    new Sequence()\n        .animation()\n            .on(token)\n            .fadeIn(1000)\n        .play();\n    await Sequencer.EffectManager.endEffects({ name: \"Invisible\", object: token });\n}","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"core":{"sourceId":"Macro.4kHSLUSKB3QkneWv"}}}
{"_id":"gU05Ao19uKUf5H2h","name":"Rage","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"icons/skills/wounds/injury-face-impact-orange.webp","scope":"global","command":"let token = args[1].sourceToken\nif (args[0] == \"on\") {\n    new Sequence()\n        .effect()\n            .file(\"jb2a.extras.tmfx.outpulse.circle.02.normal\")\n            .atLocation(token)\n            .size(4, {gridUnits: true})\n            .opacity(0.25)\n        .effect()\n            .file(\"jb2a.impact.ground_crack.orange.01\")\n            .atLocation(token)\n            .belowTokens()\n            .filter(\"ColorMatrix\", {hue: -15,saturate: 1})\n            .size(3.5, {gridUnits: true})\n            .zIndex(1)\n        .effect()\n            .file(\"jb2a.impact.ground_crack.still_frame.01\")\n            .atLocation(token)\n            .belowTokens()\n            .fadeIn(2000)\n            .filter(\"ColorMatrix\", {hue: -15,saturate: 1})\n            .size(3.5, {gridUnits: true})\n            .fadeOut(20000)\n            .zIndex(0)\n        .effect()\n            .file(\"jb2a.wind_stream.white\")\n            .atLocation(token)\n            .offset({y:75})\n            .size(1.75, {gridUnits: true})\n            .rotate(90)\n            .opacity(0.9)\n            .filter(\"ColorMatrix\", {saturate: 1})\n            .tint(\"#FF0000\")\n            .loopProperty(\"sprite\", \"position.y\", { from: -5, to: 5, duration: 50, pingPong: true})\n            .duration(8000)\n            .fadeOut(3000)\n        .effect()\n            .file(\"jb2a.particles.outward.orange.01.03\")\n            .atLocation(token)\n            .scaleToObject(2.5)\n            .opacity(1)\n            .fadeIn(200)\n            .fadeOut(3000)\n            .loopProperty(\"sprite\", \"position.x\", { from: -5, to: 5, duration: 50, pingPong: true})\n            .animateProperty(\"sprite\", \"position.y\", { from: 0, to: -100, duration: 6000, pingPong: true, delay:2000})\n            .duration(8000)\n        .effect()\n            .file(\"jb2a.wind_stream.white\")\n            .atLocation(token)\n            .name(\"Rage\")\n            .attachTo(token)\n            .scaleToObject()\n            .rotate(90)\n            .fadeOut(3000)\n            .opacity(1)\n            .filter(\"ColorMatrix\", {saturate: 1})\n            .tint(\"#FF0000\")\n            .persist()\n        .effect()\n            .file(\"jb2a.token_border.circle.static.orange.012\")\n            .atLocation(token)\n            .name(\"Rage\")\n            .attachTo(token)\n            .opacity(0.6)\n            .fadeOut(3000)\n            .scaleToObject(1.9)\n            .filter(\"ColorMatrix\", {saturate: 1})\n            .tint(\"#FF0000\")\n            .persist()\n        .play()\n\n} else if (args[0] == \"off\") {\n    await Sequencer.EffectManager.endEffects({ name: \"Rage\", object: token })\n}","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"core":{"sourceId":"Macro.hqr7muUDzlQbaZfg"}}}
{"_id":"kz6IN257FJ58SgmE","name":"Harm","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"systems/pf2e/icons/spells/harm.webp","scope":"global","command":"let diceNumber = args[0]._roll.terms[0].number\nlet caster = args[1].sourceToken\nlet spellTarget = Array.from(game.user.targets)[0]\nlet doNotTargetCaster = false\n\nlet d = new Dialog({\n    title: \"Harm\",\n    content: \"<p>How many actions are you using to cast Harm?</p>\",\n    buttons: {\n    one: {\n    icon: '<span class=\"pf2-icon\">1</span>',\n    label: \"One Action\",\n    callback: () => {\n        spellTarget = Array.from(game.user.targets)[0]\n        oneActionHarm()\n        }\n    },\n    two: {\n    icon: '<span class=\"pf2-icon\">2</span>',\n    label: \"Two Actions\",\n    callback: () => {\n        d2.render(true);\n        }\n    },\n    three:{\n    icon: `<span class=\"pf2-icon\">3</span>`,\n    label: \"Three Actions\",\n    callback: () => {\n        d3.render(true);\n        }\n    }\n    },\n    default: \"Two Actions\"\n})\n\nlet d2 = new Dialog({\n    title: \"Harm\",\n    content: `<p>Post Increased Healing?</p>`,\n    buttons: {\n    one: {\n    label: \"Yes\",\n    callback: () => {\n        let r = new Roll(`8 * @diceNumber`, {diceNumber})\n        r.toMessage()\n        spellTarget = Array.from(game.user.targets)[0]\n        twoActionHarm()\n        }\n    },\n    two: {\n    label: \"No\",\n    callback: () => {\n        spellTarget = Array.from(game.user.targets)[0]\n        twoActionHarm()\n        }\n    }\n    },\n    default: \"No\"\n})\n\nlet d3 = new Dialog({\n    title: \"Harm\",\n    content: `<p>Do you want to target yourself?</p>`,\n    buttons: {\n    one: {\n    label: \"Yes\",\n    callback: () => {\n        doNotTargetCaster = false\n        threeActionHarm()\n        }\n    },\n    two: {\n    label: \"No\",\n    callback: () => {\n        doNotTargetCaster = true\n        threeActionHarm()\n        }\n    }\n    },\n    default: \"No\"\n})\n\n\nmain()\n\nfunction main(){\n    if(caster != undefined){\n        d.render(true);\n    }else{\n        ui.notifications.error(`You must select the token of the caster!`)\n        return;\n    }    \n}\n\n//Defining unique behavior for each kind of effect\n\n\nfunction oneActionHarm(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) < 7.5){\n            console.log(\"Close enough to touch!\")\n            // checks whether the target is undead or not\n            oneActionHarmAnimation()\n        }else{\n            console.log(`Too far to touch!`); \n            ui.notifications.error(`Your target is further than touch distance away! Try again.`);\n            return;\n        }    \n}\n\nfunction twoActionHarm(){\n    //error checking for multiple targets\n    if (game.user.targets.size!= 1){\n        ui.notifications.error(\"Select only one target!\")\n        return;\n    }\n    if(canvas.grid.measureDistance(caster,spellTarget) <= 30){\n        console.log(\"Within 30 feet!\")\n        // checks whether the target is undead or not\n        twoActionHarmAnimation()\n    }else{\n        console.log(`Farther than 30 feet!`); \n        ui.notifications.error(`Your target is further than 30 feet away! Try again.`);\n        return;\n    }\n}\n\nfunction threeActionHarm(){\n    //divide up all tokens within range into an array for living and an array for undead\n    let tokensOnMap = Array.from(canvas.tokens.placeables)\n    let tokensInRange = tokensOnMap.filter(distance => canvas.grid.measureDistance(distance,caster)<=30)\n    let tokenTraitsInRange = tokensInRange.map(x => x.actor.traits)\n    let undeadTokensInRange = []\n    let livingTokensInRange = []\n    for(let i=0;i<tokensInRange.length;i++){\n        if(Array.from(tokenTraitsInRange[i]).includes(`undead`)){\n            undeadTokensInRange.push(tokensInRange[i])\n        }else if(!Array.from(tokenTraitsInRange[i]).includes(`undead`) && !Array.from(tokenTraitsInRange[i]).includes(`construct`)){\n            if (doNotTargetCaster) {\n                if (!(caster === tokensInRange[i])) livingTokensInRange.push(tokensInRange[i])\n            } else livingTokensInRange.push(tokensInRange[i])\n  \n        }\n    }\n    console.log(undeadTokensInRange)\n    console.log(livingTokensInRange)\n    new Sequence()\n        .effect()\n            .atLocation(caster)\n            .randomRotation()\n            .size(15, {gridUnits: true})\n            .file(\"jb2a.healing_generic.burst.purplepink\")\n            .waitUntilFinished(-1500)\n        .play()\n    for(let i=0;i<undeadTokensInRange.length;i++){\n        new Sequence(\"Heal Undead\")\n            .effect()\n                .atLocation(undeadTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.cure_wounds.400px.purple\")\n            .play()\n    }\n    for(let i=0;i<livingTokensInRange.length;i++){\n        new Sequence(\"Harm living\")\n            .effect()\n                .atLocation(livingTokensInRange[i])\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.divine_smite.caster.dark_purple\")\n            .effect()\n                .atLocation(livingTokensInRange[i])\n                .scaleToObject()\n                .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                .delay(500)\n            .play()\n    }\n}\n\n//Defining animations for each kind of effect\n    function oneActionHarmAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n        //trigger energy strand from caster to target, then trigger healing burst on target\n        new Sequence(\"Heal undead\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.cure_wounds.400px.purple\")\n            .play()\n        }else{\n        //trigger energy strand from caster to target, then trigger damaging burst on target\n        new Sequence(\"Harm living\")\n            .effect()\n                .atLocation(spellTarget)\n                .randomRotation()\n                .scaleToObject(1.25)\n                .file(\"jb2a.divine_smite.caster.dark_purple\")\n            .effect()\n                .atLocation(spellTarget)\n                .scaleToObject()\n                .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                .delay(500)\n            .play()\n        }\n    }\n    function twoActionHarmAnimation(){\n        if(Array.from(spellTarget.actor.traits).includes(`undead`)){\n            //trigger energy strand from caster to target, then trigger healing burst on target\n            new Sequence(\"Heal undead\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_purple\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"jb2a.cure_wounds.400px.purple\")\n                .play()\n        }else{\n            //trigger energy strand from caster to target, then trigger damaging burst on target\n            new Sequence(\"Harm living\")    \n                .effect()\n                    .atLocation(caster)\n                    .stretchTo(spellTarget)\n                    .file(\"jb2a.energy_strands.range.standard.dark_purple\")\n                    .waitUntilFinished(-1000)\n                .effect()\n                    .atLocation(spellTarget)\n                    .randomRotation()\n                    .scaleToObject(1.25)\n                    .file(\"jb2a.divine_smite.caster.dark_purple\")\n                .effect()\n                    .atLocation(spellTarget)\n                    .scaleToObject()\n                    .file(\"jb2a.toll_the_dead.purple.skull_smoke\")\n                    .delay(500)\n                .play()\n        }\n    }\n    function threeActionHarmAnimation(){\n        \n    }","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.OHxEXANJvgNk9uTU"}}}
{"name":"Grim Tendrils","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"icons/magic/unholy/energy-smoke-pink.webp","scope":"global","command":"const template = args[1].templateData;\nconst [templateX, templateY] = [template.data.x, template.data.y];\nnew Sequence()\n    .effect()\n        .file('jb2a.energy_strands.range.multiple.dark_purple.01')\n        .fadeIn(500)\n        .fadeOut(500)\n        .atLocation(template)\n        .rotateTowards(template)\n        .stretchTo(template)\n        .scale({ x: 1.4 })\n        .spriteOffset({ x: -150 })\n    .play()","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"advanced-macros":{"runAsGM":false},"exportSource":{"world":"hogwarts","system":"pf2e","coreVersion":"9.269","systemVersion":"3.10.2.11602"},"core":{"sourceId":"Macro.1wpIPbvbCvQaueft"}},"_id":"pC8bqYNdqGeeUoWO"}
{"_id":"y2Hundr4PzbGNeys","name":"Bless_Animation","type":"script","author":"ynn7ZMgoRi8oPGYQ","img":"systems/pf2e/icons/spells/bless.webp","scope":"global","command":"let caster = args[1].sourceToken\n\nlet blessAnim = Sequencer.EffectManager.getEffects({ origin: \"BlessAnim\", source: caster })[0]\n\nlet thereIsIntro = Sequencer.EffectManager.getEffects({ origin: \"BlessAnim\", name: \"Bless Intro\" })[0] //locates the bless animation created by Bless_Animation\n\nfunction main() {\n    //checks to ensure a single token is selected\n    if (canvas.tokens.controlled.length == 0) {\n        ui.notifications.error(\"Select the token on which a bless effect is active.\")\n        return\n    } else if (canvas.tokens.controlled.length > 1) {\n        ui.notifications.error(\"Select only one token.\")\n        return\n    }\n}\nif (blessAnim) {\n    let endAnimation = await warpgate.menu({\n        inputs: [{ type: 'info', label: 'End, Keep, or Expand the Bless Animation?'},],\n        buttons: [{\n            label: 'End',\n            value: 1\n        }, {\n            label: 'Keep',\n            value: 2\n        }, {\n            label: 'Expand',\n            value: 3\n        }]\n    }, { title: \"Bless\" })\n    console.log(endAnimation)\n    if (endAnimation.buttons === 1) {\n        Sequencer.EffectManager.endEffects({ origin: \"BlessAnim\", source: caster })[0]\n    } else if (endAnimation.buttons === 3) {\n        let incrementValue = 3; //3 is the value for radius = 1 square\n\n        main()\n\n        //checks to make sure bless is active on the selected token\n        if (Sequencer.EffectManager.getEffects({ origin: \"BlessAnim\", source: caster })[0] === undefined) {\n            ui.notifications.error(`There are no instances of the bless effect active on this token.`)\n            return\n        }\n\n        //increments the radius of the effect by 1 square\n        blessAnim.update({\n            size: {\n                width: blessAnim.data.size.width + incrementValue,\n                height: blessAnim.data.size.height + incrementValue,\n                gridUnits: true\n            }\n        })\n    }\n\n} else if (!thereIsIntro) {\n    new Sequence(\"Bless\")\n        .effect()\n            .file(\"jb2a.bless.400px.intro.yellow\")\n            .scaleIn(2, 1000, {ease: \"easeInBounce\"})\n            .atLocation(caster)\n            .waitUntilFinished(-500)\n            .name(\"Bless Intro\")\n            .origin(\"BlessAnim\")\n        .effect()\n            .file(\"jb2a.bless.400px.loop.yellow\")\n            .atLocation(caster)\n            .fadeOut(500)\n            .persist()\n            .attachTo(caster)\n            .belowTokens(true)\n            .origin(\"BlessAnim\")\n            .name(\"Bless\")\n            .scaleOut(0, 500, {ease: \"easeOutCubic\"})\n            .size(4, { gridUnits: true })\n        .play()\n}","folder":null,"sort":0,"permission":{"default":0,"ynn7ZMgoRi8oPGYQ":3},"flags":{"core":{"sourceId":"Macro.eJJhPoLdv7ul62dc"},"advanced-macros":{"runAsGM":false}}}
